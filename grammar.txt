Variables :
IF ELSE PLUS MINUS TIMES POW DIVIDED MOD EQUALS RETURN BRACE1 BRACE2 KURAWAL1 KURAWAL2 GT LT SERU DOT COMMA COLON SEMICOLON PETIK1 PETIK2 STRING BOOL NEW TRUE FALSE BREAK CONST SWITCH CASE DEFAULT TRY CATCH FINALLY THROW LET VAR CONTINUE DELETE FOR FUNC_SYNTAX NULL WHILE DO
Productions;
IF -> if;
ELSE -> else;
PLUS -> +;
MINUS -> -;
TIMES -> *;
POW -> **;
DIVIDED -> /;
COM1 -> //;
COM2 -> /*;
COM3 -> */;
MOD -> %;
EQUALS3 -> ===;
EQUALS2-> ==;
EQUALS -> =;
RETURN -> return;
BRACE1 -> (;
BRACE2 -> );
SQUARE1 -> [;
SQUARE2 -> ];
KURAWAL1 -> {;
KURAWAL2 -> };
UNDERSCORE -> _;
GT -> >;
LT -> <;
SERU -> !;
DOT -> .;
COMMA -> ,;
COLON -> :;
SEMICOLON -> ;;
HASHTAG -> #;
PETIK1 -> ';
PETIK2 -> ";
STR -> String;
BOOL -> Boolean;
AND -> &&;
OR -> ||;
NEW -> new;
TRUE -> true;
FALSE -> false;
BREAK -> break;
CONST -> const;
SWITCH -> switch;
CASE -> case;
DEFAULT -> default;
TRY -> try;
CATCH -> catch;
FINALLY -> finally;
THROW -> throw;
LET -> let;
VARS -> var;
CONTINUE -> continue;
DELETE -> delete;
FOR -> for;
FUNC -> function;
NULL -> null;
WHILE -> while;
FROM -> from;
IMPORT -> import;
DO -> do;
ALPHABET ->  a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z | A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z;
NUM1 -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;
NUM2 -> 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;
NUMM -> NUM1 | NUMM NUMM;
NUMBER -> NUM2 NUMM | NUM2;
OTHER -> ~ | ` | @ | $ | ^ | & | \ | ? | SERU | HASHTAG | MOD | BRACE1 | BRACE2 | TIMES | PLUS | MINUS | COMMA | DIVIDED | COLON | LT | EQUALS | GT | SQUARE1 | SQUARE2 | UNDERSCORE | KURAWAL1 | KURAWAL2 | DOT |;
OP -> PLUS | MINUS | TIMES | DIVIDED | MOD | POW.
NL -> NL NL | newline;
KATA -> KATA KATA | ALPHABET | NUM1 | OTHER;                 
VAR_2 -> VAR_2 VAR_2 | ALPHABET | NUM;
VAR -> ALPHABET | ALPHABET VAR_2;
VALUE -> NUMBER | BOOLEAN | STRING | ARRAY | FUNC_SYNTAX | VAR | VV OP VV | BRACE1 VV BRACE2.                       
VV -> VV COMMA VV | VAR | VALUE;
COMPARE -> GT | LT | GT EQUALS | LT EQUALS | EQUALS2 | EQUALS3 | SERU EQUALS;
BOOLEAN ->  BOOLEAN AND BOOLEAN | BOOLEAN OR BOOLEAN | TRUE | FALSE | SERU BOOLEAN | VALUE COMPARE VALUE | VAR;
FUNCS_HEADER -> FUNC VAR BRACE1 VV BRACE2 | FUNC VAR BRACE1 BRACE2;
FUNC_SYNTAX -> FUNCS_HEADER KURAWAL1 CODE_FUNC KURAWAL2;
STRING -> STRING STRING | PETIK1 KATA PETIK1 | PETIK2 KATA PETIK2;
CODE1 ->  NL CODE1 | CODE1 SEMICOLON | CODE1 SEMICOLON NL | CODE1 NL| CODE1 CODE1 | IF_SYNTAX1 | TRYCATCH1 | SWITCH_SYNTAX | WHILE_SYNTAX | FORS | BREAK | CONTINUE | STRING | BOOLEAN | NUMBER | COMMENT;
CODE2 ->  NL CODE2 | CODE2 SEMICOLON | CODE2 SEMICOLON NL | CODE2 NL| CODE2 CODE2 | IF_SYNTAX2 | TRYCATCH2 | SWITCH_SYNTAX | WHILE_SYNTAX | FORS | STRING | BOOLEAN | NUMBER | COMMENT;
IFF -> IF BRACE1 BOOLEAN BRACE2;
IF_SYNTAX2 -> IFF KURAWAL1 CODE2 KURAWAL2 | IF_SYNTAX2 ELIF_SYNTAX2 | IF_SYNTAX2 ELSE_SYNTAX2;
IF_SYNTAX1 -> IFF KURAWAL1 CODE1 KURAWAL2 | IF_SYNTAX1 ELIF_SYNTAX1 | IF_SYNTAX1 ELSE_SYNTAX1;
ELIFF -> ELSE IF BRACE1 BOOLEAN BRACE2;
ELIF_SYNTAX1 -> ELIFF KURAWAL1 CODE1 KURAWAL2 | ELIF_SYNTAX1 ELIF_SYNTAX1 | ELIF_SYNTAX1 ELSE_SYNTAX1;
ELIF_SYNTAX2 -> ELIFF KURAWAL1 CODE2 KURAWAL2 | ELIF_SYNTAX2 ELIF_SYNTAX2 | ELIF_SYNTAX2 ELSE_SYNTAX2;
ELSE_SYNTAX1 -> ELSE KURAWAL1 CODE1 KURAWAL2; 
ELSE_SYNTAX2 -> ELSE KURAWAL1 CODE2 KURAWAL2; 
WHILES -> WHILE BRACE1 BOOLEAN BRACE2;
WHILE_SYNTAX -> WHILES KURAWAL1 CODE1 KURAWAL2;
ARRAY -> SQUARE1 VV SQUARE2;
CONST_SYNTAX -> CONST VAR EQUALS VALUE;
SWITCH_HEADER -> SWITCH BRACE1 VAR BRACE2;
SWITCH_SYNTAX -> SWITCH_HEADER KURAWAL1 CASE_SYNTAX KURAWAL2;
DEFAULT_SYNTAX -> DEFAULT COLON CODE1 ;
CASE_SYNTAX -> CASE VALUE COLON CODE1 | CASE_SYNTAX CASE_SYNTAX | CASE_SYNTAX NL DEFAULT_SYNTAX;
VARS -> VAR VARIABLE EQUAL VALUE | VAR VARIABLE
LETS -> LET VARIABLE EQUAL VALUE | LET VARIABLE
FOR_CONDITION -> LETS | VAR EQUAL VAR | VAR EQUAL NUMBER
FOR_HEADER1 -> FOR BRACE1 FOR_CONDITION SEMICOLON FOR_CONDITON SEMICOLON FOR_CONDITION BRACE2
FOR_HEADER2 -> FOR BRACE1 SEMICOLON FOR_CONDITON SEMICOLON FOR_CONDITION BRACE2
FOR_HEADER3 -> FOR BRACE1 FOR_CONDITION SEMICOLON SEMICOLON FOR_CONDITION BRACE2
FOR_HEADER4 -> FOR BRACE1 FOR_CONDITION SEMICOLON FOR_CONDITON SEMICOLON BRACE2
FOR_HEADER5 -> FOR BRACE1 SEMICOLON SEMICOLON FOR_CONDITION BRACE2
FOR_HEADER6 -> FOR BRACE1 FOR_CONDITION SEMICOLON SEMICOLON BRACE2
FOR_HEADER7 -> FOR BRACE1 SEMICOLON FOR_CONDITON SEMICOLON BRACE2
FOR_HEADER8 -> FOR BRACE1 SEMICOLON SEMICOLON BRACE2
FORS_HEADER -> FOR_HEADER1 | FOR_HEADER2 | FOR_HEADER3 | FOR_HEADER4 | FOR_HEADER5 | FOR_HEADER6 | FOR_HEADER7 | FOR_HEADER8
FORS -> FORS_HEADER KURAWAL1 CODE1 KURAWAL2
TRYCATCH1_1 -> TRY KURAWAL1 CODE1 KURAWAL2 CATCH BRACE1 VAR BRACE2 KURAWAL1 CODE1 KURAWAL2;
TRYCATCH1_2 -> TRY KURAWAL1 CODE2 KURAWAL2 CATCH BRACE1 VAR BRACE2 KURAWAL1 CODE2 KURAWAL2;
TRYCATCH2_1 -> TRY KURAWAL1 CODE1 KURAWAL2 CATCH BRACE1 VAR BRACE2 KURAWAL1 CODE1 KURAWAL2 FINALLY KURAWAL1 CODE1 KURAWAL2;
TRYCATCH2_2 -> TRY KURAWAL1 CODE2 KURAWAL2 CATCH BRACE1 VAR BRACE2 KURAWAL1 CODE2 KURAWAL2 FINALLY KURAWAL1 CODE2 KURAWAL2;
TRYCATCH3_1 -> TRY KURAWAL1 CODE1 KURAWAL2 FINALLY KURAWAL1 CODE1 KURAWAL2
TRYCATCH3_2 -> TRY KURAWAL1 CODE2 KURAWAL2 FINALLY KURAWAL1 CODE2 KURAWAL2
COMS -> COMS COMS | NL | KATA;
COMMENT -> COM1 KATA NL | COM2 COMS COM3;
TRYCATCH1 -> TRYCATCH1_1 | TRYCATCH2_1 | TRYCATCH3_1;
TRYCATCH2 -> TRYCATCH1_2 | TRYCATCH2_2 | TRYCATCH3_2;
CODE_FUNC1 ->  NL CODE_FUNC | CODE_FUNC NL | CODE_FUNC SEMICOLON | CODE_FUNC CODE_FUNC | IF_FUNC_SYNTAX1 | WHILE_FUNC_SYNTAX | FORS_FUNC | BREAK | CONTINUE | STRING | BOOLEAN | NUMBER | RETURN | TRYCATCH1_FUNC |COMMENT ;
CODE_FUNC2 ->  NL CODE_FUNC | CODE_FUNC NL | CODE_FUNC SEMICOLON | CODE_FUNC CODE_FUNC | IF_FUNC_SYNTAX2 | WHILE_FUNC_SYNTAX | FORS_FUNC | STRING | BOOLEAN | NUMBER | RETURN | TRYCATCH2_FUNC | COMMENT;
IF_FUNC_SYNTAX1 -> IFF KURAWAL1 CODE_FUNC1 KURAWAL2 | IF_FUNC_SYNTAX ELIF_FUNC_SYNTAX | IF_FUNC_SYNTAX ELSE_FUNC_SYNTAX;
IF_FUNC_SYNTAX2 -> IFF KURAWAL1 CODE_FUNC2 KURAWAL2 | IF_FUNC_SYNTAX ELIF_FUNC_SYNTAX | IF_FUNC_SYNTAX ELSE_FUNC_SYNTAX;
ELIF_FUNC_SYNTAX1 -> ELIFF KURAWAL1 CODE_FUNC1 KURAWAL2 | ELIF_FUNC_SYNTAX ELIF_FUNC_SYNTAX | ELIF_FUNC_SYNTAX ELSE_FUNC_SYNTAX;
ELIF_FUNC_SYNTAX2 -> ELIFF KURAWAL1 CODE_FUNC KURAWAL2 | ELIF_FUNC_SYNTAX ELIF_FUNC_SYNTAX | ELIF_FUNC_SYNTAX ELSE_FUNC_SYNTAX | ELIFF CONTINUE;
ELSE_FUNC_SYNTAX -> ELSE KURAWAL1 CODE_FUNC KURAWAL2 | ELSE KURAWAL1 CONTINUE KURAWAL2;
WHILE_FUNC_SYNTAX -> WHILES KURAWAL1 CODE_FUNC1 KURAWAL2;
SWITCH_FUNC_SYNTAX -> SWITCH_HEADER KURAWAL1 CASE_FUNC_SYNTAX KURAWAL2;
DEFAULT_FUNC_SYNTAX -> DEFAULT COLON CODE_FUNC1;
CASE_FUNC_SYNTAX -> CASE VALUE COLON CODE_FUNC1| CASE_FUNC_SYNTAX CASE_FUNC_SYNTAX | CASE_FUNC_SYNTAX NL DEFAULT_FUNC_SYNTAX;
FORS_FUNC -> FORS_HEADER KURAWAL1 CODE_FUNC1 KURAWAL2;
TRYCATCH11_FUNC -> TRY KURAWAL1 CODE_FUNC1 KURAWAL2 CATCH BRACE1 VAR BRACE2 KURAWAL1 CODE_FUNC1 KURAWAL2;
TRYCATCH12_FUNC -> TRY KURAWAL1 CODE_FUNC2 KURAWAL2 CATCH BRACE1 VAR BRACE2 KURAWAL1 CODE_FUNC2 KURAWAL2;
TRYCATCH21_FUNC -> TRY KURAWAL1 CODE_FUNC1 KURAWAL2 CATCH BRACE1 VAR BRACE2 KURAWAL1 CODE_FUNC1 KURAWAL2 FINALLY KURAWAL1 CODE_FUNC1 KURAWAL2;
TRYCATCH22_FUNC -> TRY KURAWAL1 CODE_FUNC2 KURAWAL2 CATCH BRACE1 VAR BRACE2 KURAWAL1 CODE_FUNC2 KURAWAL2 FINALLY KURAWAL1 CODE_FUNC2 KURAWAL2;
TRYCATCH31_FUNC -> TRY KURAWAL1 CODE_FUNC1 KURAWAL2 FINALLY KURAWAL1 CODE_FUNC1 KURAWAL2;
TRYCATCH32_FUNC -> TRY KURAWAL1 CODE_FUNC2 KURAWAL2 FINALLY KURAWAL1 CODE_FUNC2 KURAWAL2;
TRYCATCH1_FUNC -> TRYCATCH11_FUNC | TRYCATCH21_FUNC | TRYCATCH31_FUNC;
TRYCATCH2_FUNC -> TRYCATCH12_FUNC | TRYCATCH22_FUNC | TRYCATCH32_FUNC;
