Terminals:
( ) none , and or not true false + - * / % = < > ! is in " ' [ ] { } for : # if elif else while break continue pass def return range raise class from import as with
Variables:
IF ELSE PLUS MINUS TIMES POW DIVIDED MOD EQUALS RETURN BRACE1 BRACE2 KURAWAL1 KURAWAL2 GT LT SERU DOT COMMA COLON SEMICOLON PETIK1 PETIK2 STRING BOOL NEW TRUE FALSE BREAK CONST SWITCH CASE DEFAULT TRY CATCH FINALLY THROW LET VAR CONTINUE DELETE FOR FUNC_SYNTAX NULL WHILE DO
Productions:
IF -> if;
ELSE -> else;
PLUS -> +;
MINUS -> -;
TIMES -> *;
POW -> **;
DIVIDED -> /;
COM1 -> //;
COM2 -> /*;
COM3 -> */;
MOD -> %;
EQUALS3 -> ===;
EQUALS2-> ==;
EQUALS -> =;
RETURN -> return;
BRACE1 -> (;
BRACE2 -> );
BRACE1NL -> NL BRACE1 | BRACE1 NL | NL BRACE1 NL | BRACE1 ;
BRACE2NL -> BRACE2 NL | NL BRACE2 | NL BRACE2 NL | BRACE2 ;
SQUARE1 -> [;
SQUARE2 -> ];
KURAWAL1 -> {;
KURAWAL2 -> };
KURAWAL1NL -> KURAWAL1 NL | NL KURAWAL1 | NL KURAWAL1 NL | KURAWAL1 ;
KURAWAL2NL -> KURAWAL2 NL | NL KURAWAL2 | NL KURAWAL2 NL | KURAWAL2 ;
SEMICOLONNL -> SEMICOLON | SEMICOLON NL | NL ;
UNDERSCORE -> _;
GT -> >;
LT -> <;
SERU -> !;
DOT -> .;
COMMA -> ,;
COMMANL -> COMMA NL | NL COMMA | NL COMMA NL | COMMA ;
COLON -> :;
COLONNL -> COLON | COLON NL | NL COLON | NL COLON NL ;
SEMICOLON -> ;;
HASHTAG -> #;
PETIK1 -> ';
PETIK2 -> ";
STR -> String;
BOOL -> Boolean;
AND -> &&;
OR -> ||;
NEW -> new;
TRUE -> true;
FALSE -> false;
BREAK -> break;
CONST -> const;
SWITCH -> switch;
CASE -> case;
DEFAULT -> default;
TRY -> try;
CATCH -> catch;
FINALLY -> finally;
THROW -> throw;
LET -> let;
VARS -> var;
CONTINUE -> continue;
DELETE -> delete;
FOR -> for;
FUNC -> function;
NULL -> null;
WHILE -> while;
FROM -> from;
IMPORT -> import;
DO -> do;
ALPHABET ->  a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z | A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z;
NUM1 -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;
NUM2 -> 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;
NUMM -> NUM1 | NUMM NUMM;
NUMBER -> NUM2 NUMM | NUM2;
OTHER -> ~ | ` | @ | $ | ^ | & | \ | ? | SERU | HASHTAG | MOD | BRACE1 | BRACE2 | TIMES | PLUS | MINUS | COMMA | DIVIDED | COLON | LT | EQUALS | GT | SQUARE1 | SQUARE2 | UNDERSCORE | KURAWAL1 | KURAWAL2 | DOT |;
OP -> PLUS | MINUS | TIMES | DIVIDED | MOD | POW.
NL -> NL NL | newline;
KATA -> KATA KATA | ALPHABET | NUM1 | OTHER;                 
VAR_2 -> VAR_2 VAR_2 | ALPHABET | NUM;
VAR -> ALPHABET | ALPHABET VAR_2;
VALUE -> NULL | NUMBER | BOOLEAN | STRING | ARRAY | FUNC_CALL | VAR | VV OP VV | BRACE1 VV BRACE2 | KURAWAL1 DICT_VAR KURAWAL2 | ARROWFUNCT ;                      
VV -> VV COMMA VV | VAR | VALUE;
COMPARE -> GT | LT | GT EQUALS | LT EQUALS | EQUALS2 | EQUALS3 | SERU EQUALS;
BOOLEAN ->  BOOLEAN AND BOOLEAN | BOOLEAN OR BOOLEAN | TRUE | FALSE | SERU BOOLEAN | VALUE COMPARE VALUE | VAR;

FUNC_CALL -> VAR BRACE1 VV BRACE2 ;
FUNCS_HEADER -> FUNC VAR BRACE1NL VV BRACE2NL | FUNC VAR BRACE1NL BRACE2NL;
FUNC_SYNTAX -> FUNCS_HEADER KURAWAL1NL CODE_FUNC KURAWAL2NL;
STRING -> STRING STRING | PETIK1 KATA PETIK1 | PETIK2 KATA PETIK2;

CODE1 ->  NL CODE1 | CODE1 SEMICOLON | CODE1 SEMICOLON NL | CODE1 NL| CODE1 CODE1 | IF_SYNTAX1 | TRYCATCH1 | SWITCH_SYNTAX | WHILE_SYNTAX | FORS | BREAK | CONTINUE | STRING | BOOLEAN | NUMBER | COMMENT;
CODE2 ->  NL CODE2 | CODE2 SEMICOLON | CODE2 SEMICOLON NL | CODE2 NL| CODE2 CODE2 | IF_SYNTAX2 | TRYCATCH2 | SWITCH_SYNTAX | WHILE_SYNTAX | FORS | STRING | BOOLEAN | NUMBER | COMMENT;
CODE3 ->  NL CODE2 | CODE2 SEMICOLON | CODE2 SEMICOLON NL | CODE2 NL| CODE2 CODE2 | IF_SYNTAX2 | TRYCATCH2 | SWITCH_SYNTAX | WHILE_SYNTAX | FORS | STRING | BOOLEAN | NUMBER | COMMENT | FUNC_SYNTAX;

IFF -> IF BRACE1NL BOOLEAN BRACE2NL;
ELIFF -> ELSE IF BRACE1NL BOOLEAN BRACE2NL;

IFF_SYNTAX1 -> IFF KURAWAL1NL CODE1 KURAWAL2NL ;
ELIF_SYNTAX1 -> NL ELIF KURAWAL1NL CODE1 KURAWAL2NL | ELIF KURAWAL1NL CODE1 KURAWAL2NL | ELIF_SYNTAX1 ELIF_SYNTAX1 ;
ELSE_SYNTAX1 -> NL ELSE KURAWAL1NL CODE1 KURAWAL2NL | ELSE KURAWAL1NL CODE1 KURAWAL2NL ;
IF_SYNTAX1 -> IFF_SYNTAX1 | IFF_SYNTAX1 ELIF_SYNTAX1 | IFF_SYNTAX1 ELIF_SYNTAX1 ELSE_SYNTAX1 ;

IFF_SYNTAX2 -> IFF KURAWAL2NL CODE2 KURAWAL2NL ;
ELIF_SYNTAX2 -> NL ELIF KURAWAL2NL CODE2 KURAWAL2NL | ELIF KURAWAL2NL CODE2 KURAWAL2NL | ELIF_SYNTAX2 ELIF_SYNTAX2 ;
ELSE_SYNTAX2 -> NL ELSE KURAWAL2NL CODE2 KURAWAL2NL | ELSE KURAWAL2NL CODE2 KURAWAL2NL ;
IF_SYNTAX2 -> IFF_SYNTAX2 | IFF_SYNTAX2 ELIF_SYNTAX2 | IFF_SYNTAX2 ELIF_SYNTAX2 ELSE_SYNTAX2 ;

WHILES -> WHILE BRACE1NL BOOLEAN BRACE2NL;
WHILE_SYNTAX -> WHILES KURAWAL1NL CODE1 KURAWAL2NL;

ARRAY -> SQUARE1 VV SQUARE2;

CONST_SYNTAX -> CONST VAR EQUAL VALUE SEMICOLONNL | CONST VAR SEMICOLONNL | CONST VAR EQUAL ARROWFUNCT SEMICOLONNL ;
LET_SYNTAX -> LET VAR EQUAL VALUE SEMICOLONNL | LET VAR SEMICOLONNL | LET VAR EQUAL ARROWFUNCT SEMICOLONNL ;
VAR_SYNTAX -> VARS VAR EQUAL VALUE SEMICOLONNL | VARS VAR SEMICOLONNL | VARS VAR EQUAL ARROWFUNCT SEMICOLONNL ;
BEBAS_SYNTAX -> VAR EQUAL VALUE SEMICOLONNL | VAR SEMICOLONNL ;
DICT_VAR -> VAR COLON VALUE | DICT COMMANL DICT ;
DICT_CHILD -> VAR DOT VAR | DICT_CHILD DOT VAR
DELETE_SYNTAX -> DELETE VAR | DELETE DICT_CHILD ;
THROW_SYNTAX -> THROW VALUE; 

SWITCH_HEADER -> SWITCH BRACE1NL VAR BRACE2NL;
SWITCH_SYNTAX -> SWITCH_HEADER KURAWAL1NL CASE_DEFAULT_SYNTAX KURAWAL2NL;
DEFAULT_SYNTAX -> DEFAULT COLONNL CODE1 ;
CASE_SYNTAX -> CASE VALUE COLONNL CODE1 | CASE_SYNTAX CASE_SYNTAX ;
CASE_DEFAULT_SYNTAX -> CASE_SYNTAX | CASE_SYNTAX NL DEFAULT_SYNTAX ;

FOR_CONDITION -> LETS | VAR EQUAL VAR | VAR EQUAL NUMBER
FOR_HEADER1 -> FOR BRACE1NL FOR_CONDITION SEMICOLONNL FOR_CONDITON SEMICOLONNL FOR_CONDITION BRACE2NL
FOR_HEADER2 -> FOR BRACE1NL SEMICOLONNL FOR_CONDITON SEMICOLONNL FOR_CONDITION BRACE2NL
FOR_HEADER3 -> FOR BRACE1NL FOR_CONDITION SEMICOLONNL SEMICOLONNL FOR_CONDITION BRACE2NL
FOR_HEADER4 -> FOR BRACE1NL FOR_CONDITION SEMICOLONNL FOR_CONDITON SEMICOLONNL BRACE2NL
FOR_HEADER5 -> FOR BRACE1NL SEMICOLONNL SEMICOLONNL FOR_CONDITION BRACE2NL
FOR_HEADER6 -> FOR BRACE1NL FOR_CONDITION SEMICOLONNL SEMICOLONNL BRACE2NL
FOR_HEADER7 -> FOR BRACE1NL SEMICOLONNL FOR_CONDITON SEMICOLONNL BRACE2NL
FOR_HEADER8 -> FOR BRACE1NL SEMICOLONNL SEMICOLONNL BRACE2NL
FORS_HEADER -> FOR_HEADER1 | FOR_HEADER2 | FOR_HEADER3 | FOR_HEADER4 | FOR_HEADER5 | FOR_HEADER6 | FOR_HEADER7 | FOR_HEADER8
FORS -> FORS_HEADER KURAWAL1NL CODE1 KURAWAL2NL

TRYCATCH1_1 -> TRY KURAWAL1NL CODE1 KURAWAL2NL CATCH BRACE1NL VAR BRACE2 KURAWAL1NL CODE1 KURAWAL2;
TRYCATCH2_1 -> TRY KURAWAL1NL CODE1 KURAWAL2NL CATCH BRACE1NL VAR BRACE2 KURAWAL1NL CODE1 KURAWAL2NL FINALLY KURAWAL1NL CODE1 KURAWAL2;
TRYCATCH3_1 -> TRY KURAWAL1NL CODE1 KURAWAL2NL FINALLY KURAWAL1NL CODE1 KURAWAL2

TRYCATCH1_2 -> TRY KURAWAL1NL CODE2 KURAWAL2NL CATCH BRACE1NL VAR BRACE2 KURAWAL1NL CODE2 KURAWAL2;
TRYCATCH2_2 -> TRY KURAWAL1NL CODE2 KURAWAL2NL CATCH BRACE1NL VAR BRACE2 KURAWAL1NL CODE2 KURAWAL2NL FINALLY KURAWAL1NL CODE2 KURAWAL2;
TRYCATCH3_2 -> TRY KURAWAL1NL CODE2 KURAWAL2NL FINALLY KURAWAL1NL CODE2 KURAWAL2

COMS -> COMS COMS | NL | KATA;
COMMENT -> COM1 KATA NL | COM2 COMS COM3;

TRYCATCH1 -> TRYCATCH1_1 | TRYCATCH2_1 | TRYCATCH3_1;
TRYCATCH2 -> TRYCATCH1_2 | TRYCATCH2_2 | TRYCATCH3_2;

CODE_FUNC1 ->  NL CODE_FUNC | CODE_FUNC NL | CODE_FUNC SEMICOLON | CODE_FUNC CODE_FUNC | IF_FUNC_SYNTAX1 | WHILE_FUNC_SYNTAX | FORS_FUNC | BREAK | CONTINUE | STRING | BOOLEAN | NUMBER | RETURN | TRYCATCH1_FUNC |COMMENT ;
CODE_FUNC2 ->  NL CODE_FUNC | CODE_FUNC NL | CODE_FUNC SEMICOLON | CODE_FUNC CODE_FUNC | IF_FUNC_SYNTAX2 | WHILE_FUNC_SYNTAX | FORS_FUNC | STRING | BOOLEAN | NUMBER | RETURN | TRYCATCH2_FUNC | COMMENT;

IF_FUNC_SYNTAX1 -> IFF KURAWAL1 CODE_FUNC1 KURAWAL2 | IF_FUNC_SYNTAX ELIF_FUNC_SYNTAX | IF_FUNC_SYNTAX ELSE_FUNC_SYNTAX;
IF_FUNC_SYNTAX2 -> IFF KURAWAL1 CODE_FUNC2 KURAWAL2 | IF_FUNC_SYNTAX ELIF_FUNC_SYNTAX | IF_FUNC_SYNTAX ELSE_FUNC_SYNTAX;
ELIF_FUNC_SYNTAX1 -> ELIFF KURAWAL1 CODE_FUNC1 KURAWAL2 | ELIF_FUNC_SYNTAX ELIF_FUNC_SYNTAX | ELIF_FUNC_SYNTAX ELSE_FUNC_SYNTAX;
ELIF_FUNC_SYNTAX2 -> ELIFF KURAWAL1 CODE_FUNC KURAWAL2 | ELIF_FUNC_SYNTAX ELIF_FUNC_SYNTAX | ELIF_FUNC_SYNTAX ELSE_FUNC_SYNTAX | ELIFF CONTINUE;
ELSE_FUNC_SYNTAX -> ELSE KURAWAL1 CODE_FUNC KURAWAL2 | ELSE KURAWAL1 CONTINUE KURAWAL2;

WHILE_FUNC_SYNTAX -> WHILES KURAWAL1 CODE_FUNC1 KURAWAL2;

SWITCH_FUNC_SYNTAX -> SWITCH_HEADER KURAWAL1 CASE_FUNC_SYNTAX KURAWAL2;
DEFAULT_FUNC_SYNTAX -> DEFAULT COLON CODE_FUNC1;
CASE_FUNC_SYNTAX -> CASE VALUE COLON CODE_FUNC1| CASE_FUNC_SYNTAX CASE_FUNC_SYNTAX | CASE_FUNC_SYNTAX NL DEFAULT_FUNC_SYNTAX;

FORS_FUNC -> FORS_HEADER KURAWAL1 CODE_FUNC1 KURAWAL2;

TRYCATCH11_FUNC -> TRY KURAWAL1 CODE_FUNC1 KURAWAL2 CATCH BRACE1 VAR BRACE2 KURAWAL1 CODE_FUNC1 KURAWAL2;
TRYCATCH12_FUNC -> TRY KURAWAL1 CODE_FUNC2 KURAWAL2 CATCH BRACE1 VAR BRACE2 KURAWAL1 CODE_FUNC2 KURAWAL2;
TRYCATCH21_FUNC -> TRY KURAWAL1 CODE_FUNC1 KURAWAL2 CATCH BRACE1 VAR BRACE2 KURAWAL1 CODE_FUNC1 KURAWAL2 FINALLY KURAWAL1 CODE_FUNC1 KURAWAL2;
TRYCATCH22_FUNC -> TRY KURAWAL1 CODE_FUNC2 KURAWAL2 CATCH BRACE1 VAR BRACE2 KURAWAL1 CODE_FUNC2 KURAWAL2 FINALLY KURAWAL1 CODE_FUNC2 KURAWAL2;
TRYCATCH31_FUNC -> TRY KURAWAL1 CODE_FUNC1 KURAWAL2 FINALLY KURAWAL1 CODE_FUNC1 KURAWAL2;
TRYCATCH32_FUNC -> TRY KURAWAL1 CODE_FUNC2 KURAWAL2 FINALLY KURAWAL1 CODE_FUNC2 KURAWAL2;
TRYCATCH1_FUNC -> TRYCATCH11_FUNC | TRYCATCH21_FUNC | TRYCATCH31_FUNC;
TRYCATCH2_FUNC -> TRYCATCH12_FUNC | TRYCATCH22_FUNC | TRYCATCH32_FUNC;

KURUNG -> BRACE1 VV BRACE2 | VV | BRACE1 BRACE 2 ;
ARROWFUNCT1 -> KURUNG EQUAL GT KURAWAL1NL CODE_FUNC KURAWAL2NL
ARROWFUNCT2 -> KURUNG EQUAL GT VALUE
ARROWFUNCT -> ARROWFUNCT1 | ARROWFUNCT2