Terminals:
( ) none , and or not true false + - * / % = < > ! " ' [ ] { } for : # if else let const var do while for switch case finally catch try
Variables:
IF ELSE PLUS MINUS TIMES POW DIVIDED COM1 COM2 COM3 MOD EQUALS EQUALS2 EQUALS3 RETURN BRACE1 BRACE2 BRACE1NL BRACE2NL SQUARE1 SQUARE2 KURAWAL1 KURAWAL2 KURAWAL1NL KURAWAL2NL SEMICOLONNL UNDERSCORE GT LT SERU DOT COMMA COLON COLONNL SEMICOLON HASHTAG PETIK1 PETIK2 STR BOOL NEW TRUE FALSE BREAK CONST SWITCH CASE DEFAULT TRY CATCH FINALLY THROW LET VARS CONTINUE DELETE FOR FUNC NULL WHILE FROM IMPORT DO ALPHABET NUM1 NUM2 NUMM NUMBER OTHER OP NL KATA VAR_2 VALUE VV COMPARE BOOLEAN FUNC_CALL FUNCS_HEADER FUNC_SYNTAX STRING CODE1 CODE2 SS IFF ELIFF IFF_SYNTAX1 ELIF_SYNTAX1 ELSE_SYNTAX1 IF_SYNTAX1 IFF_SYNTAX2 ELIF_SYNTAX2 ELSE_SYNTAX2 IF_SYNTAX2 WHILES WHILE_SYNTAX ARRAY OPOTHER PP CONST_SYNTAX LET_SYNTAX VAR_SYNTAX BEBAS_SYNTAX DICT_VAR DICT_CHILD DELETE_SYNTAX THROW_SYNTAX SWITCH_HEADER SWITCH_SYNTAX CASE_SYNTAX CASE_DEFAULT_SYNTAX FOR_CONDITION FOR_HEADER1 FOR_HEADER2 FOR_HEADER2 FOR_HEADER3 FOR_HEADER4 FOR_HEADER5 FOR_HEADER6 FOR_HEADER7 FOR_HEADER8 FORS_HEADER FORS TRYCATCH1_1 TRYCATCH2_1 TRYCATCH3_1 TRYCATCH1_2 TRYCATCH2_2 TRYCATCH3_2 COMS COMMENT TRYCATCH1 TRYCATCH2 CODE_FUNC1 CODE_FUNC2 IFF_FUNC_SYNTAX1 ELIF_FUNC_SYNTAX1 ELSE_FUNC_SYNTAX1 IF_FUNC_SYNTAX1 IFF_FUNC_SYNTAX2 ELIF_FUNC_SYNTAX2 ELSE_FUNC_SYNTAX2 IF_FUNC_SYNTAX2 WHILE_FUNC_SYNTAX SWITCH_FUNC_SYNTAX DEFAULT_FUNC_SYNTAX CASE_FUNC_SYNTAX CASE_DEFAULT_FUNC_SYNTAX FORS_FUNC TRYCATCH11_FUNC TRYCATCH21_FUNC TRYCATCH31_FUNC TRYCATCH11_FUNC TRYCATCH21_FUNC TRYCATCH31_FUNC TRYCATCH1_FUNC TRYCATCH2_FUNC KURUNG ARROWFUNCT1 ARROWFUNCT2 ARROWFUNCT;
Productions:
IF -> if;
ELSE -> else;
PLUS -> +;
MINUS -> -;
TIMES -> *;
POW -> **;
DIVIDED -> /;
COM1 -> //;
COM2 -> /*;
COM3 -> */;
MOD -> %;
EQUALS3 -> ===;
EQUALS2 -> ==;
EQUALS -> =;
RETURN -> return;
BRACE1 -> (;
BRACE2 -> );
BRACE1NL -> NL BRACE1 | BRACE1 NL | NL BRACE1 NL | BRACE1;
BRACE2NL -> BRACE2 NL | NL BRACE2 | NL BRACE2 NL | BRACE2;
SQUARE1 -> [;
SQUARE2 -> ];
KURAWAL1 -> {;
KURAWAL2 -> };
KURAWAL1NL -> KURAWAL1 NL | NL KURAWAL1 | NL KURAWAL1 NL | KURAWAL1;
KURAWAL2NL -> KURAWAL2 NL | NL KURAWAL2 | NL KURAWAL2 NL | KURAWAL2;
SEMICOLONNL -> SEMICOLON | SEMICOLON NL | NL;
UNDERSCORE -> _;
GT -> >;
LT -> <;
SERU -> !;
DOT -> .;
COMMA -> ,;
COMMANL -> COMMA NL | NL COMMA | NL COMMA NL | COMMA;
COLON -> :;
COLONNL -> COLON | COLON NL | NL COLON | NL COLON NL;
HASHTAG -> #;
PETIK1 -> ';
PETIK2 -> ";
STR -> String;
BOOL -> Boolean;
AND -> &&;
OR -> ||;
NEW -> new;
TRUE -> true;
FALSE -> false;
BREAK -> break;
CONST -> const;
SWITCH -> switch;
CASE -> case;
DEFAULT -> default;
TRY -> try;
CATCH -> catch;
FINALLY -> finally;
THROW -> throw;
LET -> let;
VARS -> var;
CONTINUE -> continue;
DELETE -> delete;
FOR -> for;
FUNC -> function;
NULL -> null;
WHILE -> while;
FROM -> from;
IMPORT -> import;
DO -> do;
ALPHABET ->  a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z | A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z;
NUM1 -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;
NUM2 -> 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;
NUMM -> NUM1 | NUMM NUMM;
NUMBER -> NUM2 NUMM | NUM2;
OTHER -> ~ | ` | @ | $ | ^ | & | \ | ? | SERU | HASHTAG | MOD | BRACE1 | BRACE2 | TIMES | PLUS | MINUS | COMMA | DIVIDED | COLON | LT | EQUALS | GT | SQUARE1 | SQUARE2 | UNDERSCORE | KURAWAL1 | KURAWAL2 | DOT;
OP -> PLUS | MINUS | TIMES | DIVIDED | MOD | POW;
NL -> NL NL | newline;
KATA -> KATA KATA | ALPHABET | NUM1 | OTHER;                 
VAR_2 -> VAR_2 VAR_2 | ALPHABET | NUM;
VAR -> ALPHABET | ALPHABET VAR_2;
VALUE -> NULL | NUMBER | BOOLEAN | STRING | ARRAY | FUNC_CALL | VAR | VV OP VV | BRACE1 VV BRACE2 | KURAWAL1 DICT_VAR KURAWAL2 | ARROWFUNCT;                      
VV -> VV COMMA VV | VAR | VALUE;
COMPARE -> GT | LT | GT EQUALS | LT EQUALS | EQUALS2 | EQUALS3 | SERU EQUALS;
BOOLEAN ->  BOOLEAN AND BOOLEAN | BOOLEAN OR BOOLEAN | TRUE | FALSE | SERU BOOLEAN | VALUE COMPARE VALUE | VAR;
FUNC_CALL -> VAR BRACE1 VV BRACE2;
FUNCS_HEADER -> FUNC VAR BRACE1NL VV BRACE2NL | FUNC VAR BRACE1NL BRACE2NL;
FUNC_SYNTAX -> FUNCS_HEADER KURAWAL1NL CODE_FUNC2 KURAWAL2NL;
STRING -> STRING STRING | PETIK1 KATA PETIK1 | PETIK2 KATA PETIK2;
CODE1 ->  NL CODE1 | CODE1 SEMICOLON | CODE1 SEMICOLON NL | CODE1 NL| CODE1 CODE1 | IF_SYNTAX1 | TRYCATCH1 | SWITCH_SYNTAX | WHILE_SYNTAX | FORS | BREAK | CONTINUE | STRING | BOOLEAN | NUMBER | COMMENT | CONST_SYNTAX | LET_SYNTAX | VAR_SYNTAX | BEBAS_SYNTAX | VALUE;
CODE2 ->  NL CODE2 | CODE2 SEMICOLON | CODE2 SEMICOLON NL | CODE2 NL| CODE2 CODE2 | IF_SYNTAX2 | TRYCATCH2 | SWITCH_SYNTAX | WHILE_SYNTAX | FORS | STRING | BOOLEAN | NUMBER | COMMENT | CONST_SYNTAX | LET_SYNTAX | VAR_SYNTAX | BEBAS_SYNTAX | VALUE;
SS ->  NL CODE2 | CODE2 SEMICOLON | CODE2 SEMICOLON NL | CODE2 NL| CODE2 CODE2 | IF_SYNTAX2 | TRYCATCH2 | SWITCH_SYNTAX | WHILE_SYNTAX | FORS | STRING | BOOLEAN | NUMBER | COMMENT | FUNC_SYNTAX | CONST_SYNTAX | LET_SYNTAX | VAR_SYNTAX | BEBAS_SYNTAX | VALUE;
IFF -> IF BRACE1NL BOOLEAN BRACE2NL;
ELIFF -> ELSE IF BRACE1NL BOOLEAN BRACE2NL;
IFF_SYNTAX1 -> IFF KURAWAL1NL CODE1 KURAWAL2NL;
ELIF_SYNTAX1 -> NL ELIF KURAWAL1NL CODE1 KURAWAL2NL | ELIF KURAWAL1NL CODE1 KURAWAL2NL | ELIF_SYNTAX1 ELIF_SYNTAX1;
ELSE_SYNTAX1 -> NL ELSE KURAWAL1NL CODE1 KURAWAL2NL | ELSE KURAWAL1NL CODE1 KURAWAL2NL;
IF_SYNTAX1 -> IFF_SYNTAX1 | IFF_SYNTAX1 ELIF_SYNTAX1 | IFF_SYNTAX1 ELIF_SYNTAX1 ELSE_SYNTAX1;
IFF_SYNTAX2 -> IFF KURAWAL2NL CODE2 KURAWAL2NL;
ELIF_SYNTAX2 -> NL ELIF KURAWAL2NL CODE2 KURAWAL2NL | ELIF KURAWAL2NL CODE2 KURAWAL2NL | ELIF_SYNTAX2 ELIF_SYNTAX2;
ELSE_SYNTAX2 -> NL ELSE KURAWAL2NL CODE2 KURAWAL2NL | ELSE KURAWAL2NL CODE2 KURAWAL2NL;
IF_SYNTAX2 -> IFF_SYNTAX2 | IFF_SYNTAX2 ELIF_SYNTAX2 | IFF_SYNTAX2 ELIF_SYNTAX2 ELSE_SYNTAX2;
WHILES -> WHILE BRACE1NL BOOLEAN BRACE2NL;
WHILE_SYNTAX -> WHILES KURAWAL1NL CODE1 KURAWAL2NL;
ARRAY -> SQUARE1 VV SQUARE2;
OPOTHER -> OP EQUAL ;
PP -> PLUS PLUS | MINUS MINUS ;
CONST_SYNTAX -> CONST VAR EQUAL VALUE SEMICOLONNL | CONST VAR SEMICOLONNL | CONST VAR EQUAL ARROWFUNCT SEMICOLONNL;
LET_SYNTAX -> LET VAR EQUAL VALUE SEMICOLONNL | LET VAR SEMICOLONNL | LET VAR EQUAL ARROWFUNCT SEMICOLONNL;
VAR_SYNTAX -> VARS VAR EQUAL VALUE SEMICOLONNL | VARS VAR SEMICOLONNL | VARS VAR EQUAL ARROWFUNCT SEMICOLONNL;
BEBAS_SYNTAX -> VAR EQUAL VALUE SEMICOLONNL | VAR SEMICOLONNL | VAR OPOTHER VALUE SEMICOLONNL | VAR PP SEMICOLONNL;
DICT_VAR -> VAR COLON VALUE | DICT COMMANL DICT;
DICT_CHILD -> VAR DOT VAR | DICT_CHILD DOT VAR;
DELETE_SYNTAX -> DELETE VAR | DELETE DICT_CHILD;
THROW_SYNTAX -> THROW VALUE; 
SWITCH_HEADER -> SWITCH BRACE1NL VAR BRACE2NL;
SWITCH_SYNTAX -> SWITCH_HEADER KURAWAL1NL CASE_DEFAULT_SYNTAX KURAWAL2NL;
DEFAULT_SYNTAX -> DEFAULT COLONNL CODE1;
CASE_SYNTAX -> CASE VALUE COLONNL CODE1 | CASE_SYNTAX CASE_SYNTAX;
CASE_DEFAULT_SYNTAX -> CASE_SYNTAX | CASE_SYNTAX DEFAULT_SYNTAX;
FOR_CONDITION -> LET_SYNTAX | VAR_SYNTAX | CONST_SYNTAX | VAR EQUAL VAR | VAR EQUAL NUMBER | VAR PP | VAR OPOTHER VALUE;
FOR_HEADER1 -> FOR BRACE1NL FOR_CONDITION SEMICOLONNL FOR_CONDITON SEMICOLONNL FOR_CONDITION BRACE2NL;
FOR_HEADER2 -> FOR BRACE1NL SEMICOLONNL FOR_CONDITON SEMICOLONNL FOR_CONDITION BRACE2NL;
FOR_HEADER3 -> FOR BRACE1NL FOR_CONDITION SEMICOLONNL SEMICOLONNL FOR_CONDITION BRACE2NL;
FOR_HEADER4 -> FOR BRACE1NL FOR_CONDITION SEMICOLONNL FOR_CONDITON SEMICOLONNL BRACE2NL;
FOR_HEADER5 -> FOR BRACE1NL SEMICOLONNL SEMICOLONNL FOR_CONDITION BRACE2NL;
FOR_HEADER6 -> FOR BRACE1NL FOR_CONDITION SEMICOLONNL SEMICOLONNL BRACE2NL;
FOR_HEADER7 -> FOR BRACE1NL SEMICOLONNL FOR_CONDITON SEMICOLONNL BRACE2NL;
FOR_HEADER8 -> FOR BRACE1NL SEMICOLONNL SEMICOLONNL BRACE2NL;
FORS_HEADER -> FOR_HEADER1 | FOR_HEADER2 | FOR_HEADER3 | FOR_HEADER4 | FOR_HEADER5 | FOR_HEADER6 | FOR_HEADER7 | FOR_HEADER8;
FORS -> FORS_HEADER KURAWAL1NL CODE1 KURAWAL2NL;
TRYCATCH1_1 -> TRY KURAWAL1NL CODE1 KURAWAL2NL CATCH BRACE1NL VAR BRACE2 KURAWAL1NL CODE1 KURAWAL2;
TRYCATCH2_1 -> TRY KURAWAL1NL CODE1 KURAWAL2NL CATCH BRACE1NL VAR BRACE2 KURAWAL1NL CODE1 KURAWAL2NL FINALLY KURAWAL1NL CODE1 KURAWAL2;
TRYCATCH3_1 -> TRY KURAWAL1NL CODE1 KURAWAL2NL FINALLY KURAWAL1NL CODE1 KURAWAL2;
TRYCATCH1_2 -> TRY KURAWAL1NL CODE2 KURAWAL2NL CATCH BRACE1NL VAR BRACE2 KURAWAL1NL CODE2 KURAWAL2;
TRYCATCH2_2 -> TRY KURAWAL1NL CODE2 KURAWAL2NL CATCH BRACE1NL VAR BRACE2 KURAWAL1NL CODE2 KURAWAL2NL FINALLY KURAWAL1NL CODE2 KURAWAL2;
TRYCATCH3_2 -> TRY KURAWAL1NL CODE2 KURAWAL2NL FINALLY KURAWAL1NL CODE2 KURAWAL2;
COMS -> COMS COMS | NL | KATA;
COMMENT -> COM1 KATA NL | COM2 COMS COM3;
TRYCATCH1 -> TRYCATCH1_1 | TRYCATCH2_1 | TRYCATCH3_1;
TRYCATCH2 -> TRYCATCH1_2 | TRYCATCH2_2 | TRYCATCH3_2;
CODE_FUNC1 ->  NL CODE_FUNC | CODE_FUNC NL | CODE_FUNC SEMICOLON | CODE_FUNC CODE_FUNC | IF_FUNC_SYNTAX1 | WHILE_FUNC_SYNTAX | FORS_FUNC | BREAK | CONTINUE | STRING | BOOLEAN | NUMBER | RETURN | TRYCATCH1_FUNC | COMMENT;
CODE_FUNC2 ->  NL CODE_FUNC | CODE_FUNC NL | CODE_FUNC SEMICOLON | CODE_FUNC CODE_FUNC | IF_FUNC_SYNTAX2 | WHILE_FUNC_SYNTAX | FORS_FUNC | STRING | BOOLEAN | NUMBER | RETURN | TRYCATCH2_FUNC | COMMENT;
IFF_FUNC_SYNTAX1 -> IFF KURAWAL1NL CODE_FUNC1 KURAWAL2NL;
ELIF_FUNC_SYNTAX1 -> NL ELIF KURAWAL1NL CODE_FUNC1 KURAWAL2NL | ELIF KURAWAL1NL CODE_FUNC1 KURAWAL2NL | ELIF_FUNC_SYNTAX1 ELIF_FUNC_SYNTAX1;
ELSE_FUNC_SYNTAX1 -> NL ELSE KURAWAL1NL CODE_FUNC1 KURAWAL2NL | ELSE KURAWAL1NL CODE_FUNC1 KURAWAL2NL;
IF_FUNC_SYNTAX1 -> IFF_FUNC_SYNTAX1 | IFF_FUNC_SYNTAX1 ELIF_FUNC_SYNTAX1 | IFF_FUNC_SYNTAX1 ELIF_FUNC_SYNTAX1 ELSE_FUNC_SYNTAX1;
IFF_FUNC_SYNTAX2 -> IFF KURAWAL1NL CODE_FUNC2 KURAWAL2NL;
ELIF_FUNC_SYNTAX2 -> NL ELIF KURAWAL1NL CODE_FUNC2 KURAWAL2NL | ELIF KURAWAL1NL CODE_FUNC2 KURAWAL2NL | ELIF_FUNC_SYNTAX2 ELIF_FUNC_SYNTAX2;
ELSE_FUNC_SYNTAX2 -> NL ELSE KURAWAL1NL CODE_FUNC2 KURAWAL2NL | ELSE KURAWAL1NL CODE_FUNC2 KURAWAL2NL;
IF_FUNC_SYNTAX2 -> IFF_FUNC_SYNTAX2 | IFF_FUNC_SYNTAX2 ELIF_FUNC_SYNTAX2 | IFF_FUNC_SYNTAX2 ELIF_FUNC_SYNTAX2 ELSE_FUNC_SYNTAX2;
WHILE_FUNC_SYNTAX -> WHILES KURAWAL1NL CODE_FUNC1 KURAWAL2NL;
SWITCH_FUNC_SYNTAX -> SWITCH_HEADER KURAWAL1NL CASE_DEFAULT_FUNC_SYNTAX KURAWAL2NL;
DEFAULT_FUNC_SYNTAX -> DEFAULT COLONNL CODE_FUNC1;
CASE_FUNC_SYNTAX -> CASE VALUE COLONNL CODE_FUNC1 | CASE_FUNC_SYNTAX CASE_FUNC_SYNTAX;
CASE_DEFAULT_FUNC_SYNTAX -> CASE_FUNC_SYNTAX | CASE_FUNC_SYNTAX DEFAULT_FUNC_SYNTAX;
FORS_FUNC -> FORS_HEADER KURAWAL1NL CODE_FUNC1 KURAWAL2NL;
TRYCATCH11_FUNC -> TRY KURAWAL1NL CODE_FUNC1 KURAWAL2NL CATCH BRACE1NL VAR BRACE2 KURAWAL1NL CODE_FUNC1 KURAWAL2;
TRYCATCH21_FUNC -> TRY KURAWAL1NL CODE_FUNC1 KURAWAL2NL CATCH BRACE1NL VAR BRACE2 KURAWAL1NL CODE_FUNC1 KURAWAL2NL FINALLY KURAWAL1NL CODE_FUNC1 KURAWAL2;
TRYCATCH31_FUNC -> TRY KURAWAL1NL CODE_FUNC1 KURAWAL2NL FINALLY KURAWAL1NL CODE_FUNC1 KURAWAL2 ;
TRYCATCH11_FUNC -> TRY KURAWAL1NL CODE_FUNC2 KURAWAL2NL CATCH BRACE1NL VAR BRACE2 KURAWAL1NL CODE_FUNC2 KURAWAL2;
TRYCATCH21_FUNC -> TRY KURAWAL1NL CODE_FUNC2 KURAWAL2NL CATCH BRACE1NL VAR BRACE2 KURAWAL1NL CODE_FUNC2 KURAWAL2NL FINALLY KURAWAL1NL CODE_FUNC2 KURAWAL2;
TRYCATCH31_FUNC -> TRY KURAWAL1NL CODE_FUNC2 KURAWAL2NL FINALLY KURAWAL1NL CODE_FUNC2 KURAWAL2 ;
TRYCATCH1_FUNC -> TRYCATCH11_FUNC | TRYCATCH21_FUNC | TRYCATCH31_FUNC;
TRYCATCH2_FUNC -> TRYCATCH12_FUNC | TRYCATCH22_FUNC | TRYCATCH32_FUNC;
KURUNG -> BRACE1 VV BRACE2 | VV | BRACE1 BRACE 2;
ARROWFUNCT1 -> KURUNG EQUAL GT KURAWAL1NL CODE_FUNC KURAWAL2NL;
ARROWFUNCT2 -> KURUNG EQUAL GT VALUE;
ARROWFUNCT -> ARROWFUNCT1 | ARROWFUNCT2